---
description: 
globs: 
alwaysApply: true
---
# Testing Requirements for All Tasks

Every feature implementation must include both unit and end-to-end tests to ensure proper functionality, maintainability, and reliability.

- **Test Coverage Requirements**
  - Every new component must have corresponding unit tests
  - Every user-facing feature must have end-to-end tests
  - Logic-heavy utilities must have comprehensive unit tests
  - Critical user flows must be covered by end-to-end tests

```typescript
// ✅ DO: Structure your code to be easily testable
// Component example with clear props and logic separation
export function UserProfile({ userId, onUpdate }: UserProfileProps) {
  const { data, isLoading, error } = useUserData(userId);
  
  // Isolate logic in testable functions
  const displayName = formatUserName(data);
  
  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div data-testid="user-profile">
      <h2>{displayName}</h2>
      <button onClick={() => onUpdate(userId)}>Update Profile</button>
    </div>
  );
}

// ❌ DON'T: Mix concerns or make components difficult to test
export function UserProfileBad() {
  // Mixing state, fetch logic, and rendering makes testing harder
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch('/api/user').then(r => r.json()).then(setUser);
  }, []);
  
  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

- **Test Implementation for All Tasks**
  - **Unit/Component Tests**:
    - Write tests using React Testing Library for all components
    - Follow unit testing best practices in [react-testing-library.mdc](mdc:.cursor/rules/react-testing-library.mdc)
    - Include tests for success and error states
    - Test boundary conditions and edge cases
    
  - **End-to-End Tests**:
    - Implement Playwright tests for all user-facing features
    - Follow E2E testing best practices in [playwright.mdc](mdc:.cursor/rules/playwright.mdc)
    - Cover critical user flows and scenarios
    - Test on multiple browsers when appropriate
    
  - **Smoke Tests**:
    - Run `npm run build` to verify the project builds without errors
    - Fix any TypeScript errors, linting issues, or build failures immediately
    - Include smoke tests in CI pipeline to catch build issues early
    - Verify build output for expected files and size

```typescript
// Task implementation checklist
/*
✅ Implemented feature/component
✅ Unit tests covering main functionality
✅ Unit tests for edge cases
✅ E2E tests for user flows
✅ Accessibility tests
✅ Smoke test (verify build succeeds)
*/
```

- **Build Verification Process**
  - Run `npm run build` after implementing a new feature
  - Address any TypeScript errors that appear during build
  - Check for console warnings that might indicate potential issues
  - Verify bundle size hasn't unexpectedly increased

```bash
# ✅ DO: Verify build as part of the development process
npm run build

# Look for error messages like:
# TypeScript error: Property 'X' does not exist on type 'Y'
# Failed to compile
# Module not found: Can't resolve 'some-package'

# ✅ DO: Add build verification to CI pipeline
# .github/workflows/ci.yml
- name: Build
  run: npm run build
  # This step should fail if there are any build errors
```

- **Test Organization**
  - Place unit tests alongside the code being tested with `.test.ts` or `.spec.ts` suffix
  - Organize E2E tests in a dedicated `e2e` or `playwright` directory
  - Group tests logically by feature, component, or user flow
  - Use descriptive file and test names

```
src/
  components/
    Button/
      Button.tsx
      Button.test.tsx  // Unit tests next to implementation
  features/
    auth/
      Login.tsx
      Login.test.tsx
      useAuth.ts
      useAuth.test.ts
e2e/
  auth.spec.ts        // E2E tests in dedicated directory
  navigation.spec.ts
```

- **Test Planning for Tasks**
  - Include explicit test plans in task descriptions
  - Specify what aspects need unit testing
  - Outline end-to-end test scenarios
  - Consider edge cases and error conditions to test

```
Task: Implement User Login
...
Test Strategy:
- Unit Tests:
  - Test form validation (empty fields, invalid email)
  - Test login success and error states
  - Test loading state display
- E2E Tests:
  - Test successful login flow
  - Test invalid credentials error
  - Test "forgot password" flow
  - Test redirection to previous page after login
- Smoke Test:
  - Verify build succeeds with no errors after implementation
```

- **Test Data Management**
  - Create test data factories to generate consistent test data
  - Use explicit test data instead of randomized values for predictable tests
  - Reset test data between tests to ensure isolation
  - Consider data environments (test, staging) for E2E tests

```typescript
// ✅ DO: Create test data factories
// test-utils/factories.ts
export function createTestUser(overrides = {}) {
  return {
    id: 'test-user-1',
    name: 'Test User',
    email: 'test@example.com',
    role: 'user',
    ...overrides
  };
}

// In tests
test('renders user information', () => {
  const testUser = createTestUser({ name: 'Custom Name' });
  render(<UserProfile user={testUser} />);
  expect(screen.getByText('Custom Name')).toBeInTheDocument();
});
```

- **Comprehensive Remote Request Mocking Strategy**
  - Create a consistent mocking approach across test levels
  - Use appropriate tools for each test level
  - Test all error states and edge cases
  - Avoid reliance on actual network requests in tests
  - Mock authentication for protected routes

```typescript
// ✅ DO: Use different mock strategies for different test types

// Unit Tests: MSW (Mock Service Worker) for React Testing Library
// setupTests.ts
import { setupServer } from 'msw/node';
import { rest } from 'msw';

const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(ctx.json([{ id: 1, name: 'Test User' }]));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Example unit test with MSW
test('loads and displays users', async () => {
  render(<UserList />);
  expect(screen.getByText(/loading/i)).toBeInTheDocument();
  expect(await screen.findByText('Test User')).toBeInTheDocument();
});

// Integration Tests: Mock specific API modules
// __mocks__/api.ts
export const api = {
  getUser: jest.fn(),
  createUser: jest.fn(),
};

// Example integration test with mocked module
test('creates a user when form is submitted', async () => {
  api.createUser.mockResolvedValue({ id: 1, name: 'New User' });
  
  render(<UserForm />);
  await userEvent.type(screen.getByLabelText(/name/i), 'New User');
  await userEvent.click(screen.getByRole('button', { name: /create/i }));
  
  expect(api.createUser).toHaveBeenCalledWith({ name: 'New User' });
  expect(await screen.findByText(/user created/i)).toBeInTheDocument();
});

// E2E Tests: Playwright route interception
// Example e2e test with network mocking
test('user workflow', async ({ page }) => {
  // Mock authentication
  await page.route('**/api/auth/me', route => 
    route.fulfill({ status: 200, body: JSON.stringify({ id: 1, name: 'Test User' }) })
  );
  
  // Mock user list
  await page.route('**/api/users', route => 
    route.fulfill({ 
      status: 200, 
      body: JSON.stringify([{ id: 1, name: 'Test User' }]) 
    })
  );
  
  await page.goto('/dashboard');
  await expect(page.getByText('Test User')).toBeVisible();
});
```

- **Mock Consistency Across Test Suites**
  - Use consistent mock data between unit, integration, and E2E tests
  - Create a central repository of mock response templates
  - Ensure mocks accurately reflect API response structures
  - Version mock data alongside schema changes

```typescript
// ✅ DO: Create a shared mock data repository
// test-utils/mock-data/users.ts
export const mockUsers = [
  { id: 1, name: 'Test User', email: 'test@example.com', role: 'admin' },
  { id: 2, name: 'Regular User', email: 'user@example.com', role: 'user' }
];

// test-utils/mock-data/products.ts
export const mockProducts = [
  { id: 'p1', name: 'Test Product', price: 19.99, inStock: true },
  { id: 'p2', name: 'Another Product', price: 29.99, inStock: false }
];

// ✅ DO: Create mock response generators for common APIs
// test-utils/mock-responses/users.ts
import { mockUsers } from '../mock-data/users';

export const getUserResponse = (id) => {
  const user = mockUsers.find(u => u.id === Number(id));
  if (!user) {
    return { status: 404, body: { error: 'User not found' } };
  }
  return { status: 200, body: user };
};

export const getUsersResponse = (query = {}) => {
  let filteredUsers = [...mockUsers];
  
  // Apply query filters
  if (query.role) {
    filteredUsers = filteredUsers.filter(u => u.role === query.role);
  }
  
  return { status: 200, body: filteredUsers };
};

// Usage in unit tests with MSW
rest.get('/api/users', (req, res, ctx) => {
  const role = req.url.searchParams.get('role');
  const response = getUsersResponse({ role });
  return res(ctx.status(response.status), ctx.json(response.body));
});

// Usage in E2E tests with Playwright
await page.route('**/api/users', route => {
  const url = new URL(route.request().url());
  const role = url.searchParams.get('role');
  const response = getUsersResponse({ role });
  route.fulfill({ status: response.status, body: JSON.stringify(response.body) });
});
```

- **API Error Testing**
  - Systematically test all error responses
  - Verify error handling UI for each API integration
  - Create reusable error response factories
  - Test network failures, not just error status codes

```typescript
// ✅ DO: Test various API error scenarios
// Error types to test for each API integration:
// 1. HTTP error codes (400, 401, 403, 404, 500)
// 2. Network failures
// 3. Malformed responses
// 4. Slow responses

// Example: Testing error states in unit tests
test('handles 401 unauthorized error', async () => {
  server.use(
    rest.get('/api/users', (req, res, ctx) => {
      return res(
        ctx.status(401),
        ctx.json({ message: 'Unauthorized' })
      );
    })
  );
  
  render(<UserList />);
  expect(await screen.findByText(/please log in/i)).toBeInTheDocument();
});

test('handles network failure', async () => {
  server.use(
    rest.get('/api/users', (req, res) => {
      return res.networkError('Failed to connect');
    })
  );
  
  render(<UserList />);
  expect(await screen.findByText(/network error/i)).toBeInTheDocument();
});

// Example: Testing slow responses
test('shows loading state for slow response', async () => {
  server.use(
    rest.get('/api/users', async (req, res, ctx) => {
      await new Promise(resolve => setTimeout(resolve, 1000));
      return res(ctx.json(mockUsers));
    })
  );
  
  render(<UserList />);
  expect(screen.getByText(/loading/i)).toBeInTheDocument();
  expect(await screen.findByText('Test User')).toBeInTheDocument();
});
```

- **Testing Schedule and Process**
  - Run unit tests on every code change
  - Run E2E tests before PRs are merged
  - Include visual regression tests for UI-heavy features
  - Analyze test coverage periodically
  - Run smoke tests (`npm run build`) before submitting PRs

```typescript
// Example package.json test scripts
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:ci": "npm run test && npm run build && npm run test:e2e",
    "test:smoke": "npm run build"
  }
}
```

- **Test Documentation**
  - Document test preconditions and requirements
  - Include examples of how to run specific test suites
  - Document any environment setup needed for tests
  - Keep a record of test coverage for critical features

```typescript
/**
 * @file Authentication E2E Tests
 * 
 * Prerequisites:
 * - Test database must be seeded with test users (run `npm run seed:test`)
 * - Auth service must be running (`npm run start:auth`)
 * 
 * Run these tests with: `npm run test:e2e -- --project=auth`
 */
```

- **Accessibility Testing Requirements**
  - Include accessibility checks in both unit and E2E test suites
  - Use axe-core with React Testing Library for component-level checks
  - Use Playwright's accessibility testing tools for E2E checks
  - Test keyboard navigation for interactive elements

```typescript
// ✅ DO: Include accessibility tests
// Unit test example with axe-core
import { axe } from 'jest-axe';

test('form has no accessibility violations', async () => {
  const { container } = render(<LoginForm />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});

// E2E test example
test('login form is accessible', async ({ page }) => {
  await page.goto('/login');
  const accessibilityScanResults = await page.accessibility.snapshot();
  expect(accessibilityScanResults.violations).toEqual([]);
});
```

- **Critical Test Scenarios by Feature Type**
  - **Forms**:
    - Field validation
    - Submission success/failure
    - Loading states
    - Error message display
  - **Data Display**:
    - Loading states
    - Empty states
    - Error states
    - Pagination/infinite scroll
  - **Authentication**:
    - Login/logout flows
    - Registration
    - Password reset
    - Auth state persistence
  - **Navigation**:
    - Routing
    - Deep linking
    - Protected routes
    - Redirects

```typescript
// Example test matrix for a form component
describe('RegistrationForm', () => {
  // Input validation tests
  test('validates email format', async () => {/* ... */});
  test('requires password with minimum length', async () => {/* ... */});
  test('requires matching password confirmation', async () => {/* ... */});
  
  // Form submission tests
  test('shows loading state during submission', async () => {/* ... */});
  test('displays server errors', async () => {/* ... */});
  test('redirects after successful registration', async () => {/* ... */});
  
  // Accessibility tests
  test('form is fully keyboard navigable', async () => {/* ... */});
  test('has no accessibility violations', async () => {/* ... */});
});
```

