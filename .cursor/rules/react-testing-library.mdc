---
description: 
globs: 
alwaysApply: false
---
# React Testing Library Best Practices

React Testing Library encourages testing your application the way users interact with it, focusing on behavior rather than implementation details.

- **Test User Behavior, Not Implementation**
  - Focus on what the user sees and does, not internal component logic
  - Use queries that reflect how users find elements (text, role, label)
  - Avoid testing component state directly

```typescript
// ✅ DO: Test what the user sees
test('renders the welcome message', () => {
  render(<Welcome />);
  expect(screen.getByText(/welcome/i)).toBeInTheDocument();
});

// ❌ DON'T: Test implementation details
test('sets isOpen state to true', () => {
  const wrapper = shallow(<Menu />);
  wrapper.instance().setState({ isOpen: true });
  expect(wrapper.state('isOpen')).toBe(true);
});
```

- **Prefer User-Centric Queries**
  - Use query priority: getByRole > getByLabelText > getByPlaceholderText > getByText > getByDisplayValue > getByAltText > getByTitle > getByTestId
  - Always try to use semantic queries that relate to user experience

```typescript
// ✅ DO: Use semantic queries
getByRole('button', { name: /submit/i })
getByLabelText(/email address/i)
getByText(/welcome/i)

// ❌ DON'T: Default to test IDs
getByTestId('submit-button')
```

- **Use Proper Assertions**
  - Use Jest DOM matchers for more readable assertions
  - Prefer assertions about visibility, presence, or absence of elements

```typescript
// ✅ DO: Use jest-dom matchers
expect(element).toBeVisible();
expect(element).toBeDisabled();
expect(element).toHaveTextContent('Expected text');

// ❌ DON'T: Use generic assertions that don't convey intent
expect(element.textContent).toBe('Expected text');
expect(element.disabled).toBe(true);
```

- **Handle Async Operations Properly**
  - Use `findBy` queries for elements that appear asynchronously
  - Prefer `waitFor` over arbitrary timeouts
  - Test loading states where appropriate

```typescript
// ✅ DO: Use async queries for dynamic content
test('shows the data after fetching', async () => {
  render(<DataFetcher />);
  expect(screen.getByText(/loading/i)).toBeInTheDocument();
  expect(await screen.findByText(/data loaded/i)).toBeInTheDocument();
});

// ❌ DON'T: Use setTimeout or fixed waits
test('shows data after loading', async () => {
  render(<DataFetcher />);
  await new Promise(r => setTimeout(r, 1000)); // Avoid this
  expect(screen.getByText(/data loaded/i)).toBeInTheDocument();
});
```

- **Mock Remote Requests Effectively**
  - Use consistent mocking strategies for all HTTP requests
  - Prefer MSW (Mock Service Worker) for API mocking
  - Test success, error, and loading states for data fetching components
  - Reset mocks between tests to avoid test interdependencies

```typescript
// ✅ DO: Use MSW for API mocking (setup in test files or a central handler)
// setupTests.ts
import { setupServer } from 'msw/node';
import { rest } from 'msw';

export const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(ctx.json([
      { id: 1, name: 'John Doe' },
      { id: 2, name: 'Jane Smith' }
    ]));
  }),
  
  rest.get('/api/users/:id', (req, res, ctx) => {
    const { id } = req.params;
    return res(ctx.json({ id: Number(id), name: 'John Doe' }));
  }),
  
  rest.post('/api/users', (req, res, ctx) => {
    return res(ctx.status(201), ctx.json({ id: 3, ...req.body }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// ✅ DO: Test different API response scenarios
test('shows error UI when API fails', async () => {
  // Override the default handler for this specific test
  server.use(
    rest.get('/api/users', (req, res, ctx) => {
      return res(ctx.status(500), ctx.json({ message: 'Internal error' }));
    })
  );
  
  render(<UserList />);
  expect(screen.getByText(/loading/i)).toBeInTheDocument();
  expect(await screen.findByText(/error loading users/i)).toBeInTheDocument();
});

// ✅ DO: For simpler cases, use Jest mock functions
// __mocks__/axios.ts
export default {
  get: jest.fn(),
  post: jest.fn(),
  // other methods
};

// In your test file
import axios from 'axios';

beforeEach(() => {
  jest.clearAllMocks();
});

test('fetches and displays user data', async () => {
  axios.get.mockResolvedValueOnce({ 
    data: { name: 'John', email: 'john@example.com' } 
  });
  
  render(<UserProfile userId="123" />);
  
  expect(axios.get).toHaveBeenCalledWith('/api/users/123');
  expect(await screen.findByText('John')).toBeInTheDocument();
});

// ❌ DON'T: Mock fetch globally without resetting
global.fetch = jest.fn(() => 
  Promise.resolve({
    json: () => Promise.resolve({ data: 'test' })
  })
); // Avoid this approach
```

- **User Interaction Testing**
  - Use `userEvent` over `fireEvent` for more realistic user interactions
  - Chain interactions to test complex user flows
  - Verify the outcome of interactions, not the mechanics

```typescript
// ✅ DO: Use userEvent for realistic interactions
test('submits the form with user data', async () => {
  render(<Form />);
  await userEvent.type(screen.getByLabelText(/username/i), 'testuser');
  await userEvent.type(screen.getByLabelText(/password/i), 'password123');
  await userEvent.click(screen.getByRole('button', { name: /submit/i }));
  
  expect(await screen.findByText(/welcome, testuser/i)).toBeInTheDocument();
});

// ❌ DON'T: Use fireEvent directly for user interactions
test('submits the form', () => {
  render(<Form />);
  fireEvent.change(screen.getByLabelText(/username/i), { target: { value: 'testuser' } });
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));
});
```

- **Follow the AAA Pattern (Arrange-Act-Assert)**
  - Structure tests with clear separation between setup, action, and verification
  - Use comments or blank lines to separate these phases when helpful

```typescript
// ✅ DO: Structure tests with the AAA pattern
test('shows success message after submission', async () => {
  // Arrange
  render(<ContactForm />);
  
  // Act
  await userEvent.type(screen.getByLabelText(/email/i), 'user@example.com');
  await userEvent.type(screen.getByLabelText(/message/i), 'Hello there');
  await userEvent.click(screen.getByRole('button', { name: /send/i }));
  
  // Assert
  expect(await screen.findByText(/message sent/i)).toBeInTheDocument();
});
```

- **Keep Tests Focused and Independent**
  - Each test should verify one specific behavior
  - Tests should not depend on other tests
  - Use `beforeEach` for common setup, but keep it minimal

```typescript
// ✅ DO: Write focused tests
test('disables submit button when form is empty', () => {
  render(<ContactForm />);
  expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();
});

test('enables submit button when form is filled', async () => {
  render(<ContactForm />);
  await userEvent.type(screen.getByLabelText(/email/i), 'user@example.com');
  expect(screen.getByRole('button', { name: /submit/i })).toBeEnabled();
});

// ❌ DON'T: Test multiple behaviors in one test
test('form validation and submission works', async () => {
  render(<ContactForm />);
  expect(screen.getByRole('button')).toBeDisabled();
  await userEvent.type(screen.getByLabelText(/email/i), 'user@example.com');
  expect(screen.getByRole('button')).toBeEnabled();
  await userEvent.click(screen.getByRole('button'));
  expect(await screen.findByText(/success/i)).toBeInTheDocument();
});
```

- **Setup Testing Environment Properly**
  - Reset mocks and document after each test
  - Mock external dependencies consistently
  - Use a standardized test setup file

```typescript
// ✅ DO: Clean up after each test
afterEach(() => {
  jest.resetAllMocks();
  cleanup();
});

// ✅ DO: Setup consistent mocks
beforeEach(() => {
  jest.spyOn(global, 'fetch').mockImplementation(() => 
    Promise.resolve({
      json: () => Promise.resolve({ data: 'test data' }),
      ok: true,
    } as Response)
  );
});
```

- **Test Accessibility**
  - Include accessibility checks in your tests
  - Test keyboard navigation where appropriate
  - Verify ARIA attributes and roles

```typescript
// ✅ DO: Test accessibility
test('modal can be closed with Escape key', async () => {
  render(<Modal isOpen={true} />);
  expect(screen.getByRole('dialog')).toBeInTheDocument();
  
  await userEvent.keyboard('{Escape}');
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});

test('form has proper accessibility attributes', () => {
  render(<SignupForm />);
  const form = screen.getByRole('form');
  expect(form).toHaveAttribute('aria-labelledby');
});
```

- **Write Maintainable Test Descriptions**
  - Use descriptive test names that explain the behavior
  - Follow a consistent naming convention
  - Consider using nested describe blocks for organization

```typescript
// ✅ DO: Use descriptive test names
describe('SignupForm', () => {
  describe('validation', () => {
    test('shows error message when email is invalid', async () => {
      // Test code
    });
    
    test('shows error message when password is too short', async () => {
      // Test code
    });
  });
  
  describe('submission', () => {
    test('calls API with user data when form is valid', async () => {
      // Test code
    });
  });
});
```

